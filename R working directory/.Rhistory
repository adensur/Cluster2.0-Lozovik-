}
molecular<-function(r,K=10000,dt=0.1,print=FALSE,plot=FALSE,fun="r", skip=10){
##K - number of molecular dynamics iterations
##print - if R should print out potential energy at each step
##plot  - if R should plot the cluster in 3D with animation of molecular dynamics
##fun: choose between options of calculating, aggregating and returning data:
##fun = "r" - simple molecular dynamics with no additional calculations, returns
##"r" object
##fun = "r.aggregate" - on every step, adds current "r" object to the general
##array and returns it in the end. (Result - an array of 6*N*K elements instead of
##a matrix of 6*N)
##fun = "Kinn" = on every step, calculates kinetic energy via function "Kinn" for
##each individual particle and adds it to a vector. Result - N*K length vector
##with kinetic energy values
##skip - integer; specifies how many iterations to skip before plotting/aggregating again
add=FALSE              ##this logical variable determines if the plot should add stuff or make new plot
N<-ncol(r)
if(fun=="Kinn"){
print("fun=Kinn specified. aggregating kinetic energies of individual particles, returning kinetic energies vector")
kinn<-NULL     ##vector of kinetic energy values
for (i in 1:K){
r<-rstep(r,dt)
r<-vstep(r,dt)
if(i%%skip==0){
for(j in 1:N){
kinn<-c(kinn,Kinn(r,n=j))
}
if(print)print(U(r))
if(plot)myplot(r,add=add)
add<-TRUE
}
}
if(print)print(U(r))
return(kinn)
}
else if (fun=="r"){
print("fun=r specified. performing simple molecular dynamics, returning r")
for (i in 1:K){
if(i%%skip==0){
if(print)print(U(r))
if(plot)myplot(r,add=add)
add<-TRUE
}
r<-rstep(r,dt)
r<-vstep(r,dt)
}
if(print)print(U(r))
return(r)
}
else if (fun=="r.aggregate"){
print("fun=r.aggregate specified. Aggregating r's into one big array and returning it")
r.aggr<-array(dim=c(6,N,K))
for (i in 1:K){
r<-rstep(r,dt)
r<-vstep(r,dt)
if(i%%skip==0){
r.aggr[,,i]<-r
if(print)print(U(r))
if(plot)myplot(r,add=add)
add<-TRUE
}
}
if(print)print(U(r))
return(r.aggr)
}
}
mywrite<-function(object,type,N,K,dt,T){
##writes into a file an object, class of which is specified by "type"
if(type=="r.aggr"){
print("type=r.aggr specified. Writing into file array of r's, marking N, K, dt and T in the filename")
file<-paste(c("data_molecular/r.aggr_N=",N,"_K=",K,"_dt=",dt,"_T=",T,".csv"),collapse="")
write.csv(object,file=file,row.names=FALSE)
}
}
ro.perp<-function(x,a){
##calculates the distance between point M(x,y,z) and line s(a,b,c), where a is a vector of length 3 (a,b,c), and x
##is a vector of length 3 x,y,z
sqrt((x[2]*a[3]-a[2]*x[3])^2+(x[3]*a[1]-x[1]*a[3])^2+(x[1]*a[2]-x[2]*a[1])^2)/sqrt(a[1]^2+a[2]^2+a[3]^2)
}
ro.perp.aggr<-function(aggrn,a){
##calculates the ro.perp function between a and vectors
##x, specified by aggrn[,k]ths elements
##aggrn is an array of 3*K
K<-dim(aggrn)[2]
ro<-NULL
for(i in 1:K){
ro<-c(ro,ro.perp(aggrn[,i],a))
}
ro
}
ro.par<-function(x,a){
##calculates the distance between point of perpendicular from M(x,y,z) on the line s(a,b,c) to the beginning of coords
##, where a is a vector of length 3 (a,b,c), and x
##is a vector of length 3 x,y,z
(x[1]*a[1]+x[2]*a[2]+x[3]*a[3])/sqrt(a[1]^2+a[2]^2+a[3]^2)
}
line.search<-function(aggr,S,N, line=rnorm(3)){
##A function to search for the axis of symmetry of the system using random
##search.
## aggr - specifies the array of r objects with aggr[,,k] for each k
##being a vector of 3*N of coordinates of N particles.
##line is specified by 3 parametres a, b, c with a^2+b^2+c^2=1.
## n - specifies a particle, for which the line of symmetry is found.
alfa=1
sd1=vector(length=N)
sd2=vector(length=N)
for(i in 1:N){
sd1[i]=sd(ro.perp.aggr(aggr[,n,],line))
}
for(i in 1:S){
a2<-line-rnorm(3)/alfa
for(i in 1:N){
sd2[i]=sd(ro.perp.aggr(aggr[,n,],a2))
}
if(sd2<sd1){
line<-a2
sd1<-sd2
alfa<-alfa*0.9
}
}
line<-line/sqrt(line[1]^2+line[2]^2+line[3]^2)
print(c("returning vector for sd=",sd1))
line
}
aggr.plot<-function(aggr,line=c(0,0,0),skip=1){
##skip - an integer representing, how often to plot a vector
add<-FALSE
library(rgl)
K<-dim(aggr)[3]
for(i in 1:K){
if(i%%skip==0){
myplot(aggr[,,i],add=add)
add<-TRUE
}
}
x<-c(0,line[1])
y<-c(0,line[2])
z<-c(0,line[3])
plot3d(x,y,z,type="l",add=TRUE)
}
##r<-gradient.descent(N=27,r=r,alfa=0.5,K=5000, print = TRUE)
##r<-reinit(N)
##ra<-rad(r)
##plot(sort(ra))
##myplot(r)
##U(r)
##hist(fun) plots distribution
dim(aggr2)
line<-line.search(aggr2,S=500,N=27)
line.search<-function(aggr,S, line=rnorm(3)){
##A function to search for the axis of symmetry of the system using random
##search.
## aggr - specifies the array of r objects with aggr[,,k] for each k
##being a vector of 3*N of coordinates of N particles.
##line is specified by 3 parametres a, b, c with a^2+b^2+c^2=1.
## n - specifies a particle, for which the line of symmetry is found.
N=dim(aggr)[2]
alfa=1
sd1=vector(length=N)
sd2=vector(length=N)
for(i in 1:N){
sd1[i]=sd(ro.perp.aggr(aggr[,n,],line))
}
for(i in 1:S){
a2<-line-rnorm(3)/alfa
for(i in 1:N){
sd2[i]=sd(ro.perp.aggr(aggr[,n,],a2))
}
if(sum(sd2)<sum(sd1)){
line<-a2
sd1<-sd2
alfa<-alfa*0.9
}
}
line<-line/sqrt(line[1]^2+line[2]^2+line[3]^2)
print(c("returning vector for sd=",sd1))
line
}
line<-line.search(aggr2,S=500,N=27)
line<-line.search(aggr2,S=500)
line.search<-function(aggr,S, line=rnorm(3)){
##A function to search for the axis of symmetry of the system using random
##search.
## aggr - specifies the array of r objects with aggr[,,k] for each k
##being a vector of 3*N of coordinates of N particles.
##line is specified by 3 parametres a, b, c with a^2+b^2+c^2=1.
## n - specifies a particle, for which the line of symmetry is found.
N=dim(aggr)[2]
alfa=1
sd1=vector(length=N)
sd2=vector(length=N)
for(i in 1:N){
sd1[i]=sd(ro.perp.aggr(aggr[,i,],line))
}
for(i in 1:S){
a2<-line-rnorm(3)/alfa
for(i in 1:N){
sd2[i]=sd(ro.perp.aggr(aggr[,i,],a2))
}
if(sum(sd2)<sum(sd1)){
line<-a2
sd1<-sd2
alfa<-alfa*0.9
}
}
line<-line/sqrt(line[1]^2+line[2]^2+line[3]^2)
print(c("returning vector for sd=",sd1))
line
}
line<-line.search(aggr2,S=500)
line<-line.search(aggr2,S=500)
debug(line.search)
line<-line.search(aggr2,S=500)
N
alfa
sd1
sd2
sd1
dim(aggr)
ro.perp.aggr(aggr[,3,line])
ro.perp.aggr(aggr[,3,],line)
line
aggr[,3,]
dim(aggr)
sum(which(is.na(aggr)))
head(aggr2)
dim(aggr2)
head(aggr)
r
K=5000
skip=35
skip=37
skip
K
K=50000
K
count<-0
for (i in 1:K){
if(i%%skip==0){
count<-count+1
}
}
count
50000%/%skip
molecular<-function(r,K=10000,dt=0.1,print=FALSE,plot=FALSE,fun="r", skip=10){
##K - number of molecular dynamics iterations
##print - if R should print out potential energy at each step
##plot  - if R should plot the cluster in 3D with animation of molecular dynamics
##fun: choose between options of calculating, aggregating and returning data:
##fun = "r" - simple molecular dynamics with no additional calculations, returns
##"r" object
##fun = "r.aggregate" - on every step, adds current "r" object to the general
##array and returns it in the end. (Result - an array of 6*N*K elements instead of
##a matrix of 6*N)
##fun = "Kinn" = on every step, calculates kinetic energy via function "Kinn" for
##each individual particle and adds it to a vector. Result - N*K length vector
##with kinetic energy values
##skip - integer; specifies how many iterations to skip before plotting/aggregating again
add=FALSE              ##this logical variable determines if the plot should add stuff or make new plot
N<-ncol(r)
if(fun=="Kinn"){
print("fun=Kinn specified. aggregating kinetic energies of individual particles, returning kinetic energies vector")
kinn<-NULL     ##vector of kinetic energy values
for (i in 1:K){
r<-rstep(r,dt)
r<-vstep(r,dt)
if(i%%skip==0){
for(j in 1:N){
kinn<-c(kinn,Kinn(r,n=j))
}
if(print)print(U(r))
if(plot)myplot(r,add=add)
add<-TRUE
}
}
if(print)print(U(r))
return(kinn)
}
else if (fun=="r"){
print("fun=r specified. performing simple molecular dynamics, returning r")
for (i in 1:K){
if(i%%skip==0){
if(print)print(U(r))
if(plot)myplot(r,add=add)
add<-TRUE
}
r<-rstep(r,dt)
r<-vstep(r,dt)
}
if(print)print(U(r))
return(r)
}
else if (fun=="r.aggregate"){
print("fun=r.aggregate specified. Aggregating r's into one big array and returning it")
r.aggr<-array(dim=c(6,N,K%/%skip))
for (i in 1:K){
r<-rstep(r,dt)
r<-vstep(r,dt)
if(i%%skip==0){
r.aggr[,,i]<-r
if(print)print(U(r))
if(plot)myplot(r,add=add)
add<-TRUE
}
}
if(print)print(U(r))
return(r.aggr)
}
}
aggr<-molecular(r,K=25000,fun="r.aggregate",skip=25)
molecular<-function(r,K=10000,dt=0.1,print=FALSE,plot=FALSE,fun="r", skip=10){
##K - number of molecular dynamics iterations
##print - if R should print out potential energy at each step
##plot  - if R should plot the cluster in 3D with animation of molecular dynamics
##fun: choose between options of calculating, aggregating and returning data:
##fun = "r" - simple molecular dynamics with no additional calculations, returns
##"r" object
##fun = "r.aggregate" - on every step, adds current "r" object to the general
##array and returns it in the end. (Result - an array of 6*N*K elements instead of
##a matrix of 6*N)
##fun = "Kinn" = on every step, calculates kinetic energy via function "Kinn" for
##each individual particle and adds it to a vector. Result - N*K length vector
##with kinetic energy values
##skip - integer; specifies how many iterations to skip before plotting/aggregating again
add=FALSE              ##this logical variable determines if the plot should add stuff or make new plot
N<-ncol(r)
if(fun=="Kinn"){
print("fun=Kinn specified. aggregating kinetic energies of individual particles, returning kinetic energies vector")
kinn<-NULL     ##vector of kinetic energy values
for (i in 1:K){
r<-rstep(r,dt)
r<-vstep(r,dt)
if(i%%skip==0){
for(j in 1:N){
kinn<-c(kinn,Kinn(r,n=j))
}
if(print)print(U(r))
if(plot)myplot(r,add=add)
add<-TRUE
}
}
if(print)print(U(r))
return(kinn)
}
else if (fun=="r"){
print("fun=r specified. performing simple molecular dynamics, returning r")
for (i in 1:K){
if(i%%skip==0){
if(print)print(U(r))
if(plot)myplot(r,add=add)
add<-TRUE
}
r<-rstep(r,dt)
r<-vstep(r,dt)
}
if(print)print(U(r))
return(r)
}
else if (fun=="r.aggregate"){
print("fun=r.aggregate specified. Aggregating r's into one big array and returning it")
r.aggr<-array(dim=c(6,N,K%/%skip))
for (i in 1:K){
r<-rstep(r,dt)
r<-vstep(r,dt)
if(i%%skip==0){
r.aggr[,,i/skip]<-r
if(print)print(U(r))
if(plot)myplot(r,add=add)
add<-TRUE
}
}
if(print)print(U(r))
return(r.aggr)
}
}
aggr<-molecular(r,K=25000,fun="r.aggregate",skip=25)
dim(aggr)
line<-line.search(aggr,S=500)
undebug(line.search)
line<-line.search(aggr,S=500)
line
aggr.plot(aggr,line=line)
aggr.plot(aggr,line=10*line)
aggr.plot(aggr,line=3*line)
line<- -line
line
x<-c(0,line[1])
y<-c(0,line[2])
z<-c(0,line[3])
plot3d(x,y,z,type="l",add=TRUE)
?plot3d
x<-c(0,line[1])
y<-c(0,line[2])
z<-c(0,line[3])
plot3d(x,y,z,type="l",add=TRUE,lwd=25)
x<-c(0,line[1])
y<-c(0,line[2])
z<-c(0,line[3])
plot3d(3*x,3*y,3*z,type="l",add=TRUE,lwd=25)
line=-line
x<-c(0,line[1])
y<-c(0,line[2])
z<-c(0,line[3])
plot3d(3*x,3*y,3*z,type="l",add=TRUE,lwd=25)
?sink
save.image("C:/Cluster2.0-Lozovik-/R working directory/symmetry line workspace.RData")
?matrix
?sapply
ro.perp.NK<-function(aggr,line){
##calculates perpendicular distance from each point in an array aggr
##returns N*K matrix
N=dim(aggr)[2]
K=dim(aggr)[3]
matrix.roperp<-matrix(nrow=N,ncol=K)
for(n in 1:N){
for(k in 1:K){
matrix.roperp[n,k]<-ro.perp(aggr[1:3,n,k],line)
}
}
matrix.roperp
}
ro1<-ro.perp.NK(aggr,line)
dim(ro1)
ro1
ro.par.NK<-function(aggr,line){
##calculates perpendicular distance from each point in an array aggr
##returns N*K matrix
N=dim(aggr)[2]
K=dim(aggr)[3]
matrix.ropar<-matrix(nrow=N,ncol=K)
for(n in 1:N){
for(k in 1:K){
matrix.roperp[n,k]<-ro.par(aggr[1:3,n,k],line)
}
}
matrix.ropar
}
ro.par.NK<-function(aggr,line){
##calculates perpendicular distance from each point in an array aggr
##returns N*K matrix
N=dim(aggr)[2]
K=dim(aggr)[3]
matrix.ropar<-matrix(nrow=N,ncol=K)
for(n in 1:N){
for(k in 1:K){
matrix.ropar[n,k]<-ro.par(aggr[1:3,n,k],line)
}
}
matrix.ropar
}
dim(ro1)
plot(ro1)
?plot
head(ro1)
plot(1,2,add=TRUE)
?plot
?plot
hist(ro1)
rug(ro1)
?sd
hist(ro1,breaks=100)
rug(ro1)
?hist
plot(ro1[1,])
value.ro1<-NULL
for(i in 1:27){
value.ro1<-c(value.ro1,ro1[i,])
}
length(value.ro1)
plot(value.ro1)
hist(value.ro1,breaks=27000)
hist(value.ro1,breaks=2700)
hist(value.ro1,breaks=270)
sd.ro1<-NULL
for(i in 1:27){
sd.ro1<-c(sd.ro1,sd(ro1[i,]))
}
sd.ro1
plot(sd.ro1)
summary(sd.ro1)
summary(value.ro1)
ro.par.NK<-function(aggr,line){
##calculates perpendicular distance from each point in an array aggr
##returns N*K matrix
N=dim(aggr)[2]
K=dim(aggr)[3]
matrix.ropar<-matrix(nrow=N,ncol=K)
for(n in 1:N){
for(k in 1:K){
matrix.ropar[n,k]<-ro.par(aggr[1:3,n,k],line)
}
}
matrix.ropar
}
ro2<-ro.par.NK(aggr,line)
dim(ro2)
value.ro2<-NULL
for(i in 1:27){
value.ro2<-c(value.ro2,ro2[i,])
}
sd.ro2<-NULL
for(i in 1:27){
sd.ro2<-c(sd.ro2,sd(ro2[i,]))
}
plot(sd.ro2)
plot(value.ro2)
summary(value.ro2)
summary(sd.ro2)
save.image("C:/Cluster2.0-Lozovik-/R working directory/symmetry line workspace.RData")
dim(aggr)
sd.ro1
length(sd.ro1)
