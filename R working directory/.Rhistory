}
grad.U<-function(r,var,k){##takes numeric vectors x,y,z, and number of particles N
##var is the variable, for which the gradient is calculated.var=1 - x, var=2 - y, var=3 - z
##k is the index of the variable in vector. (i.e., number of particle)
##so for var="x" and k=3 the gradient U by x[3] will be calculated.
N<-ncol(r)      ##number of particles
if(k>N){print("grad.U: invalid k. k is more then number of particles")}
sum<-0
for(i in 1:N){
if(i!=k){
sum<-sum+6*(r[var,k]-r[var,i])*(rki(r,k,i)^(-8))
}
}
sum<-2*r[var,k]-sum
sum
}
vgrad.U<-function(r){##based on grad.U. returns the 3*N vector of gradient
N<-ncol(r)
null<-rep(0,times=N)
grad<-rbind(null,null,null)##the initial value for vector grad is all zeroes; 3*N matrix
for(k in 1:N){
for(var in 1:3){
grad[var,k]<-grad.U(r,var,k)
}
}
grad
}
rki<-function(r,k,i){##calculates the distance between particle i and particle k;
##x, y, z (vectors) specify coordinates of all particles
rki<-NULL
if(k==i){print("rki error! k=i!")}
else{
rki<-((r[1,k]-r[1,i])^2+(r[2,k]-r[2,i])^2+(r[3,k]-r[3,i])^2)^0.5
}
names(rki)<-"Distance"
rki
}
U<-function(r){##returns a value of the potential energy of the system
N<-ncol(r)
U<-0
for(i in 1:N){
sum<-0
if(i<N){
for(k in (i+1):N){
sum<-sum+rki(r,k,i)^(-6)
}
}
U<-U+sum+r[1,i]^2+r[2,i]^2+r[3,i]^2
}
names(U)<-"Potential energy"
U
}
init<-function(N){##initializes matrix 3 times N with correct rownames and random values
r<-rbind(rnorm(N),rnorm(N),rnorm(N))
rownames(r)<-(c("x","y","z"))
r
}
delta<-function(r,alfa=1){##calculate vector of difference (one gradient descent iteration)
r2<-r
N<-ncol(r)
for(k in 1:N){
for(var in 1:3){
r2[var,k]<-r[var,k]-alfa*grad.U(r,var,k)
}
}
r2
}
reinit<-function(N){##loads r from file; returns it
file<-paste(c("data_init/",N,".csv"),collapse="")
r<-as.matrix(read.csv(file))
r
}
myplot<-function(r){##rad is a vector of shell radiuses. Particles within radk, rad(k+1) will be drown in same color
library(rgl)
plot3d(r[1,],r[2,],r[3,])##дописать функцию, чтобы рисовала частицы разных оболочек разными цветами
}##extends possibility of plot3d to plot a matrix 3xN
descent<-function(N=1:100,print=FALSE,alfa=1){##calcs descent over vector of N's and write each to a file
for(i in N){
r<-gradient.descent(i,alfa=alfa,K=100000, print=print)
file<-paste(c("data_init/",i,".csv"),collapse="")
write.csv(r,file=file,row.names=FALSE)
print(paste(c("printed file",file)),collapse="")
}
string<-paste(c("files for N=",paste(N,collapse=", ")," printed succesfully"), collapse="")
print(string)
}
rad<-function(r){##calculates the distance from particle k to the beginning of the coordinates
N<-ncol(r)
rad<-rep(0,times=N)
for(k in 1:N){
rad[k]<-(r[1,k]^2+r[2,k]^2+r[3,k]^2)^(0.5)
}
rad
}
temp<-function(r,T){##adds a small, random increments to the coordinates (r) and velocities of the system
N<-ncol(r)
dr<-rbind(rnorm(N,sd=T),rnorm(N,sd=T),rnorm(N,sd=T)) ##for now T is just the standart
##deviation of the new distribution
dv<-rbind(rnorm(N,sd=T),rnorm(N,sd=T),rnorm(N,sd=T))
r<-r+dr
r<-rbind(r,dv)
}
rstep<-function(r, dt=1){##returns a next step of the "leap frog" iteration process
N<-ncol(r)
deltar<-dt*r[4:6,]##this is now the matrix 3*N of small random increments
null<-rep(0,times=N)
null<-rbind(null,null,null)##null is now a matrix 3*N of all zeroes
deltar<-rbind(deltar,null)
rnew<-r+deltar
rnew
}
vstep<-function(r,dt=1){##same as vstep, but for velocities v
N<-ncol(r)
deltav<-dt*vgrad.U(r[1:3,])
null<-rep(0,times=N)
null<-rbind(null,null,null)##null is now a matrix 3*N of all zeroes
deltav<-rbind(null,deltav)
vnew<-r-deltav
vnew
}
descent(N=27,print=TRUE)
r<-reinit(27)
r
rad<-rad(r)
plot(rad)
myplot(r)
scatterplot3d(r[1,],r[2,],r[3,])
scatterplot3D(r[1,],r[2,],r[3,])
scatter3D(r[1,],r[2,],r[3,])
library(Rcmdr)
scatter3d(r[1,],r[2,],r[3,])
r2<-r[rad<1]
r2
rad<1
rad
sum(rad<1)
r2
r2<-r[rad<1]
r2
length(r2)
class(r2)
r
r2<-r[1:3,rad<1]
r2
myplot(r2)
r3<-r[1:3,rad>1]
r3
myplot(r3)
plot(c(0, 5), c(0, 4), type = 'n', asp = 1, ann = FALSE)
x <- c(1, 2, 2, 1.5, 1)
z <- c(1, 1, 2, 1.7, 2)
polygon(x, z, col = 'green')
?polygon
?polygon3d
polygon3d(r3[1,],r3[2,],r3[3,])
polygon3d(r[1,],r[2,],r[3,])
polygon3d(r[1,])
library(R.basic)  # plot3d() and polygon3d()
xb <- c(0, 4, 4, 0, 0)
yb <- c(0, 3, 3, 0, 0)
zb <- c(0, 0, 4, 4, 0)
plot3d(xb,yb,zb, type="l", theta=35, phi=30)
x <- c(0.8, 1.6, 1.6, 1.2, 0.8)
y <- c(0.6, 1.2, 1.2, 0.9, 0.6)
z <- c(1, 1, 2, 1.7, 2)
polygon3d(x,y,z, col="green")
?planes3d
planes3d(1,2,3)
x <- rnorm(100)
y <- rnorm(100)
z <- 0.2*x - 0.3*y + rnorm(100, sd=0.3)
fit <- lm(z ~ x + y)
plot3d(x,y,z, type="s", col="red", size=1)
coefs <- coef(fit)
a <- coefs["x"]
b <- coefs["y"]
c <- -1
d <- coefs["(Intercept)"]
planes3d(a, b, c, d, alpha=0.5)
open3d()
plot3d(x,y,z, type="s", col="red", size=1)
clipplanes3d(a, b, c, d)
?surf3d
??surf3d
?surf3D
library(plot3D)
?surf3D
surf3D(r[1,],r[2,],r[3,])
x<-r[1,]
y<-r[2,]
z<-r[3,]
x
class(x)
plot3d(xx,y,z)
plot3d(x,y,z)
surf3D(x,y,z)
X       <- seq(0, pi, length.out = 50)
Y       <- seq(0, 2*pi, length.out = 50)
M       <- mesh(X, Y)
phi     <- M$x
theta   <- M$y
# x, y and z grids
r <- sin(4*phi)^3 + cos(2*phi)^3 + sin(6*theta)^2 + cos(6*theta)^4
x <- r * sin(phi) * cos(theta)
y <- r * cos(phi)
z <- r * sin(phi) * sin(theta)
# full colored image
surf3D(x, y, z, colvar = y, colkey = FALSE, shade = 0.5,
box = FALSE, theta = 60)
?mesh
x1<-r[1,]
x2<-r[2,]
y1<-r[2,]
z1<-r[3,]
mesh(x,y,z)
mesh(x1,y1,z1)
M<-mesh(x,y,z)
M<-mesh(x1,y1,z1)
scatter3D(M$x,M$y,M$z)
x <- y <- z <- c(-1 , 0, 1)
# 3-D mesh
(M <- mesh(x, y, z))
# calculate with 3-D mesh
V <- with (M, x/2 * sin(y) *sqrt(z+2))
# plot result
scatter3D(M$x, M$y, M$z, V, pch = "+", cex = 3, colkey = FALSE)
x <- c(-1 , 0, 1)
y <- 1 : 4
# 2-D mesh
(M <- mesh(x, y))
# calculate with this mesh
V <- with (M, x/2 * sin(y))
# same as:
V2 <- outer(x, y, FUN = function(x, y) x/2*sin(y))
x <- y <- z <- c(-1 , 0, 1)
# 3-D mesh
(M <- mesh(x, y, z))
# calculate with 3-D mesh
V <- with (M, x/2 * sin(y) *sqrt(z+2))
# plot result
scatter3D(M$x, M$y, M$z, V, pch = "+", cex = 3, colkey = FALSE)
r2
x<-r2[1,]
y<-r2[2,]
z<-r3[3,]
z<-r2[3,]
z
x
y
M<-mesh(x,y,z)
class(M)
scatter3D(M$x,M$y,M$z)
scatter3D(x,y,z)
plot3d(M$x,M$y,M$z)
?surf3D
surf3D(M$X,M$y,M$z)
surf3D(M$x,M$y,M$z)
class(M$x)
M$x
M <- mesh(seq(0, 6*pi, length.out = 80),
seq(pi/3, pi, length.out = 80))
u <- M$x ; v <- M$y
x <- u/2 * sin(v) * cos(u)
y <- u/2 * sin(v) * sin(u)
z <- u/2 * cos(v)
surf3D(x, y, z, colvar = z, colkey = FALSE, box = FALSE)
class(x)
x
M <- mesh(seq(0, 6*pi, length.out = 80),
seq(pi/3, pi, length.out = 80))
u <- M$x ; v <- M$y
x <- u/2 * sin(v) * cos(u)
y <- u/2 * sin(v) * sin(u)
z <- u/2 * cos(v)
surf3D(x, y, z, colvar = z, colkey = FALSE, box = FALSE)
scatter3D(x,y,z)
surf3D(x,y,z)
M<-mesh(r[1,],r[2,],r[3,])
plot3d(M$x,M$y,M$z)
myplot(r)
r<-reinit(27)
M<-mesh(r[1,],r[2,],r[3,])
> plot3d(M$x,M$y,M$z)
M<-mesh(r[1,],r[2,],r[3,])
M<-mesh(r[1,],r[2,],r[3,])
plot3d(M$x,M$y,M$z)
r<-reinit(27)
M<-mesh(r[1,],r[2,],r[3,])
plot3d(M$x,M$y,M$z)
M <- mesh(seq(0, 6*pi, length.out = 80),
seq(pi/3, pi, length.out = 80))
u <- M$x ; v <- M$y
x <- u/2 * sin(v) * cos(u)
y <- u/2 * sin(v) * sin(u)
z <- u/2 * cos(v)
surf3D(x, y, z, colvar = z, colkey = FALSE, box = FALSE)
plot(u,v)
M <- mesh(seq(0, 2, length.out = 80),
+           seq(1, 3, length.out = 80))
u <- M$x ; v <- M$y
plot(u,v)
?mesh
library(rgl)
example(surface3d)
?surface3d
x<-r[1,]
y<-r[2,]
r
z<-r[3,]
surface3d(x,y,z)
?planes3d
?segments3d
?mesh3d
open3d()
shade3d( translate3d( tetrahedron3d(col="red"), 0, 0, 0) )
shade3d( translate3d( cube3d(col="green"), 3, 0, 0) )
shade3d( translate3d( octahedron3d(col="blue"), 6, 0, 0) )
shade3d( translate3d( dodecahedron3d(col="cyan"), 9, 0, 0) )
shade3d( translate3d( icosahedron3d(col="magenta"), 12, 0, 0) )
?translate3d
open3d()
plot3d( cube3d(col="green") )
M <- par3d("userMatrix")
if (!rgl.useNULL())
play3d( par3dinterp( userMatrix=list(M,
rotate3d(M, pi/2, 1, 0, 0),
rotate3d(M, pi/2, 0, 1, 0) ) ),
duration=4 )
## Not run:
movie3d( spin3d(), duration=5 )
x
y
z
?points3d
points3d(x,y,z)
lines3d(x,y,z)
segments3d(x,y,z)
triangles3d(x,y,z)
quads3d(x,y,z)
r2
x2<-r2[1,]
y2<-r2[1,]
z2<-r2[3,]
y2<-r2[2,]
triangles3d(x,y,z)
triangles3d(x2,y2,z2)
polygon3d(x,y,z)
?polygon3d
gradient.descent<-function(N,r,alfa=1,K=10,print=FALSE){
if(missing(r)){
r<-init(N)
print("missing r. Reinitializing randoms")
}
else{
N<-ncol(r)
}
Break<-FALSE
for(i in 1:K){
string<-paste(c("i=",i,"of 100000", " U=",U(r)),collapse="")
if(print){print(string)}
deltaU<- 1    ##difference between current U and calculated on next iteration U
t<-1          ##counter to exclude the possibility of infinite loop
while(deltaU>=0 & !Break){
r2<-delta(r,alfa=alfa)
deltaU<-U(r2)-U(r)
##print(c("delta=U",deltaU))
if(deltaU>0){
alfa<-alfa/10
##print(c("alfa=",alfa))
}
t<=t+1
if(t>=100000){Break<-TRUE}##to avoid infinite loop
break
}
if(Break){
print("Too many iterations. exiting loop")
break
}
r<-r2
}
print(U(r))
r
}
grad.U<-function(r,var,k){##takes numeric vectors x,y,z, and number of particles N
##var is the variable, for which the gradient is calculated.var=1 - x, var=2 - y, var=3 - z
##k is the index of the variable in vector. (i.e., number of particle)
##so for var="x" and k=3 the gradient U by x[3] will be calculated.
N<-ncol(r)      ##number of particles
if(k>N){print("grad.U: invalid k. k is more then number of particles")}
sum<-0
for(i in 1:N){
if(i!=k){
sum<-sum+6*(r[var,k]-r[var,i])*(rki(r,k,i)^(-8))
}
}
sum<-2*r[var,k]-sum
sum
}
vgrad.U<-function(r){##based on grad.U. returns the 3*N vector of gradient
N<-ncol(r)
null<-rep(0,times=N)
grad<-rbind(null,null,null)##the initial value for vector grad is all zeroes; 3*N matrix
for(k in 1:N){
for(var in 1:3){
grad[var,k]<-grad.U(r,var,k)
}
}
grad
}
rki<-function(r,k,i){##calculates the distance between particle i and particle k;
##x, y, z (vectors) specify coordinates of all particles
rki<-NULL
if(k==i){print("rki error! k=i!")}
else{
rki<-((r[1,k]-r[1,i])^2+(r[2,k]-r[2,i])^2+(r[3,k]-r[3,i])^2)^0.5
}
names(rki)<-"Distance"
rki
}
U<-function(r){##returns a value of the potential energy of the system
N<-ncol(r)
U<-0
for(i in 1:N){
sum<-0
if(i<N){
for(k in (i+1):N){
sum<-sum+rki(r,k,i)^(-6)
}
}
U<-U+sum+r[1,i]^2+r[2,i]^2+r[3,i]^2
}
names(U)<-"Potential energy"
U
}
init<-function(N){##initializes matrix 3 times N with correct rownames and random values
r<-rbind(rnorm(N),rnorm(N),rnorm(N))
rownames(r)<-(c("x","y","z"))
r
}
delta<-function(r,alfa=1){##calculate vector of difference (one gradient descent iteration)
r2<-r
N<-ncol(r)
for(k in 1:N){
for(var in 1:3){
r2[var,k]<-r[var,k]-alfa*grad.U(r,var,k)
}
}
r2
}
reinit<-function(N){##loads r from file; returns it
file<-paste(c("data_init/",N,".csv"),collapse="")
r<-as.matrix(read.csv(file))
r
}
myplot<-function(r){##rad is a vector of shell radiuses. Particles within radk, rad(k+1) will be drown in same color
library(rgl)
plot3d(r[1,],r[2,],r[3,])##дописать функцию, чтобы рисовала частицы разных оболочек разными цветами
}##extends possibility of plot3d to plot a matrix 3xN
descent<-function(N=1:100,print=FALSE,alfa=1){##calcs descent over vector of N's and write each to a file
for(i in N){
r<-gradient.descent(i,alfa=alfa,K=100000, print=print)
file<-paste(c("data_init/",i,".csv"),collapse="")
write.csv(r,file=file,row.names=FALSE)
print(paste(c("printed file",file)),collapse="")
}
string<-paste(c("files for N=",paste(N,collapse=", ")," printed succesfully"), collapse="")
print(string)
}
rad<-function(r){##calculates the distance from particle k to the beginning of the coordinates
N<-ncol(r)
rad<-rep(0,times=N)
for(k in 1:N){
rad[k]<-(r[1,k]^2+r[2,k]^2+r[3,k]^2)^(0.5)
}
rad
}
temp<-function(r,T){##adds a small, random increments to the coordinates (r) and velocities of the system
N<-ncol(r)
dr<-rbind(rnorm(N,sd=T),rnorm(N,sd=T),rnorm(N,sd=T)) ##for now T is just the standart
##deviation of the new distribution
dv<-rbind(rnorm(N,sd=T),rnorm(N,sd=T),rnorm(N,sd=T))
r<-r+dr
r<-rbind(r,dv)
}
rstep<-function(r, dt=1){##returns a next step of the "leap frog" iteration process
N<-ncol(r)
deltar<-dt*r[4:6,]##this is now the matrix 3*N of small random increments
null<-rep(0,times=N)
null<-rbind(null,null,null)##null is now a matrix 3*N of all zeroes
deltar<-rbind(deltar,null)
rnew<-r+deltar
rnew
}
vstep<-function(r,dt=1){##same as vstep, but for velocities v
N<-ncol(r)
deltav<-dt*vgrad.U(r[1:3,])
null<-rep(0,times=N)
null<-rbind(null,null,null)##null is now a matrix 3*N of all zeroes
deltav<-rbind(null,deltav)
vnew<-r-deltav
vnew
}
descent(28,print=TRUE)
r<-reinit(27)
U(R)
U(r)
N=27
N
r2<-gradient.descent(N,r,alfa=0.1,K=5000,print=TRUE)
U(r2)-U(r)
r3<-gradient.descent(27,alfa=0.1,k=5000,print=TRUE)
r3<-gradient.descent(27,alfa=0.1,K=5000,print=TRUE)
