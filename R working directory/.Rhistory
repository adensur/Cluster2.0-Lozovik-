for(i in 1:N){
sum<-0
if(i<N){
for(k in (i+1):N){
sum<-sum+rki(r,k,i)^(-5)
}
}
U<-U+sum+r[1,i]^2+r[2,i]^2+r[3,i]^2
}
names(U)<-"Potential energy"
U
}
init<-function(N){##initializes matrix 3 times N with correct rownames and random values
r<-rbind(rnorm(N),rnorm(N),rnorm(N))
rownames(r)<-(c("x","y","z"))
r
}
delta<-function(r,alfa=1){##calculate vector of difference (one gradient descent iteration)
r2<-r
N<-ncol(r)
for(k in 1:N){
for(var in 1:3){
r2[var,k]<-r[var,k]-alfa*grad.U(r,var,k)
}
}
r2
}
reinit<-function(N){##loads r from file; returns it
file<-paste(c("data_init/",N,".csv"),collapse="")
r<-as.matrix(read.csv(file))
r
}
myplot<-function(r){
plot3d(r2[1,],r2[2,],r2[3,])
}##extends possibility of plot3d to plot a matrix 3xN
descent<-function(N=1:100,print=FALSE){##calcs descent over vector of N's and write each to a file
for(i in N){
r<-gradient.descent(i,alfa=1,K=100000, print=print)
file<-paste(c("data_init/",i,".csv"),collapse="")
write.csv(r,file=file,row.names=FALSE)
print(paste(c("printed file",file)),collapse="")
}
print("files for N = 1:100 printed succesfully")
}
rad<-function(r,k){##calculates the distance from particle k to the beginning of the coordinates
rad<-r[1,k]^2+r[2,k]^2+r[3,k]
}
descent(20,print=TRUE)
string<-paste(c("i=",4,"of 100000", " U=",U(r)),col="")
r<-reinit(18)
r<-reinit(19)
string<-paste(c("i=",4,"of 100000", " U=",U(r)),col="")
gradient.descent<-function(N,r,alfa=1,K=10,print=FALSE){
if(missing(r)){
r<-init(N)
print("missing r. Reinitializing randoms")
}
else{
N<-ncol(r)
}
Break<-FALSE
for(i in 1:K){
string<-paste(c("i=",i,"of 100000", " U=",U(r)),col="")
if(print){print(string)}
deltaU<- 1    ##difference between current U and calculated on next iteration U
t<-1          ##counter to exclude the possibility of infinite loop
while(deltaU>=0 & !Break){
r2<-delta(r,alfa=alfa)
deltaU<-U(r2)-U(r)
##print(c("delta=U",deltaU))
if(deltaU>0){
alfa<-alfa/10
##print(c("alfa=",alfa))
}
t<=t+1
if(t>=100000){Break<-TRUE}##to avoid infinite loop
break
}
if(Break){
print("Too many iterations. exiting loop")
break
}
r<-r2
}
print(U(r))
r
}
grad.U<-function(r,var,k){##takes numeric vectors x,y,z, and number of particles N
##var is the variable, for which the gradient is calculated.var=1 - x, var=2 - y, var=3 - z
##k is the index of the variable in vector. (i.e., number of particle)
##so for var="x" and k=3 the gradient U by x[3] will be calculated.
N<-ncol(r)      ##number of particles
if(k>N){print("grad.U: invalid k. k is more then number of particles")}
sum<-0
for(i in 1:N){
if(i!=k){
sum<-sum+5*(r[var,k]-r[var,i])*(rki(r,k,i)^(-7))
}
}
sum<-2*r[var,k]-sum
sum
}
rki<-function(r,k,i){##calculates the distance between particle i and particle k;
##x, y, z (vectors) specify coordinates of all particles
rki<-NULL
if(k==i){print("rki error! k=i!")}
else{
rki<-((r[1,k]-r[1,i])^2+(r[2,k]-r[2,i])^2+(r[3,k]-r[3,i])^2)^0.5
}
names(rki)<-"Distance"
rki
}
U<-function(r){##returns a value of the potential energy of the system
N<-ncol(r)
U<-0
for(i in 1:N){
sum<-0
if(i<N){
for(k in (i+1):N){
sum<-sum+rki(r,k,i)^(-5)
}
}
U<-U+sum+r[1,i]^2+r[2,i]^2+r[3,i]^2
}
names(U)<-"Potential energy"
U
}
init<-function(N){##initializes matrix 3 times N with correct rownames and random values
r<-rbind(rnorm(N),rnorm(N),rnorm(N))
rownames(r)<-(c("x","y","z"))
r
}
delta<-function(r,alfa=1){##calculate vector of difference (one gradient descent iteration)
r2<-r
N<-ncol(r)
for(k in 1:N){
for(var in 1:3){
r2[var,k]<-r[var,k]-alfa*grad.U(r,var,k)
}
}
r2
}
reinit<-function(N){##loads r from file; returns it
file<-paste(c("data_init/",N,".csv"),collapse="")
r<-as.matrix(read.csv(file))
r
}
myplot<-function(r){
plot3d(r2[1,],r2[2,],r2[3,])
}##extends possibility of plot3d to plot a matrix 3xN
descent<-function(N=1:100,print=FALSE){##calcs descent over vector of N's and write each to a file
for(i in N){
r<-gradient.descent(i,alfa=1,K=100000, print=print)
file<-paste(c("data_init/",i,".csv"),collapse="")
write.csv(r,file=file,row.names=FALSE)
print(paste(c("printed file",file)),collapse="")
}
print("files for N = 1:100 printed succesfully")
}
rad<-function(r,k){##calculates the distance from particle k to the beginning of the coordinates
rad<-r[1,k]^2+r[2,k]^2+r[3,k]
}
descent(20,print=TRUE)
gradient.descent<-function(N,r,alfa=1,K=10,print=FALSE){
if(missing(r)){
r<-init(N)
print("missing r. Reinitializing randoms")
}
else{
N<-ncol(r)
}
Break<-FALSE
for(i in 1:K){
string<-paste(c("i=",i,"of 100000", " U=",U(r)),collapse="")
if(print){print(string)}
deltaU<- 1    ##difference between current U and calculated on next iteration U
t<-1          ##counter to exclude the possibility of infinite loop
while(deltaU>=0 & !Break){
r2<-delta(r,alfa=alfa)
deltaU<-U(r2)-U(r)
##print(c("delta=U",deltaU))
if(deltaU>0){
alfa<-alfa/10
##print(c("alfa=",alfa))
}
t<=t+1
if(t>=100000){Break<-TRUE}##to avoid infinite loop
break
}
if(Break){
print("Too many iterations. exiting loop")
break
}
r<-r2
}
print(U(r))
r
}
grad.U<-function(r,var,k){##takes numeric vectors x,y,z, and number of particles N
##var is the variable, for which the gradient is calculated.var=1 - x, var=2 - y, var=3 - z
##k is the index of the variable in vector. (i.e., number of particle)
##so for var="x" and k=3 the gradient U by x[3] will be calculated.
N<-ncol(r)      ##number of particles
if(k>N){print("grad.U: invalid k. k is more then number of particles")}
sum<-0
for(i in 1:N){
if(i!=k){
sum<-sum+5*(r[var,k]-r[var,i])*(rki(r,k,i)^(-7))
}
}
sum<-2*r[var,k]-sum
sum
}
rki<-function(r,k,i){##calculates the distance between particle i and particle k;
##x, y, z (vectors) specify coordinates of all particles
rki<-NULL
if(k==i){print("rki error! k=i!")}
else{
rki<-((r[1,k]-r[1,i])^2+(r[2,k]-r[2,i])^2+(r[3,k]-r[3,i])^2)^0.5
}
names(rki)<-"Distance"
rki
}
U<-function(r){##returns a value of the potential energy of the system
N<-ncol(r)
U<-0
for(i in 1:N){
sum<-0
if(i<N){
for(k in (i+1):N){
sum<-sum+rki(r,k,i)^(-5)
}
}
U<-U+sum+r[1,i]^2+r[2,i]^2+r[3,i]^2
}
names(U)<-"Potential energy"
U
}
init<-function(N){##initializes matrix 3 times N with correct rownames and random values
r<-rbind(rnorm(N),rnorm(N),rnorm(N))
rownames(r)<-(c("x","y","z"))
r
}
delta<-function(r,alfa=1){##calculate vector of difference (one gradient descent iteration)
r2<-r
N<-ncol(r)
for(k in 1:N){
for(var in 1:3){
r2[var,k]<-r[var,k]-alfa*grad.U(r,var,k)
}
}
r2
}
reinit<-function(N){##loads r from file; returns it
file<-paste(c("data_init/",N,".csv"),collapse="")
r<-as.matrix(read.csv(file))
r
}
myplot<-function(r){
plot3d(r2[1,],r2[2,],r2[3,])
}##extends possibility of plot3d to plot a matrix 3xN
descent<-function(N=1:100,print=FALSE){##calcs descent over vector of N's and write each to a file
for(i in N){
r<-gradient.descent(i,alfa=1,K=100000, print=print)
file<-paste(c("data_init/",i,".csv"),collapse="")
write.csv(r,file=file,row.names=FALSE)
print(paste(c("printed file",file)),collapse="")
}
print("files for N = 1:100 printed succesfully")
}
rad<-function(r,k){##calculates the distance from particle k to the beginning of the coordinates
rad<-r[1,k]^2+r[2,k]^2+r[3,k]
}
descent(20,print=TRUE)
descent(21,print=TRUE)
r<-reinit(20)
r<-reinit(21)
r
N<-1:100
string<-paste(c("files for N=",paste(N,collapse="")," printed succesfully"))
string
string<-paste(c("files for N=",paste(N,collapse=", ")," printed succesfully"))
string
string<-paste(c("files for N=",paste(N,collapse=", ")," printed succesfully"), collapse="")
print(string)
n<-21
rad<-rep(0,times=N)
/rep
?rep
rad<-rep(0,times=21)
rad
gradient.descent<-function(N,r,alfa=1,K=10,print=FALSE){
if(missing(r)){
r<-init(N)
print("missing r. Reinitializing randoms")
}
else{
N<-ncol(r)
}
Break<-FALSE
for(i in 1:K){
string<-paste(c("i=",i,"of 100000", " U=",U(r)),collapse="")
if(print){print(string)}
deltaU<- 1    ##difference between current U and calculated on next iteration U
t<-1          ##counter to exclude the possibility of infinite loop
while(deltaU>=0 & !Break){
r2<-delta(r,alfa=alfa)
deltaU<-U(r2)-U(r)
##print(c("delta=U",deltaU))
if(deltaU>0){
alfa<-alfa/10
##print(c("alfa=",alfa))
}
t<=t+1
if(t>=100000){Break<-TRUE}##to avoid infinite loop
break
}
if(Break){
print("Too many iterations. exiting loop")
break
}
r<-r2
}
print(U(r))
r
}
grad.U<-function(r,var,k){##takes numeric vectors x,y,z, and number of particles N
##var is the variable, for which the gradient is calculated.var=1 - x, var=2 - y, var=3 - z
##k is the index of the variable in vector. (i.e., number of particle)
##so for var="x" and k=3 the gradient U by x[3] will be calculated.
N<-ncol(r)      ##number of particles
if(k>N){print("grad.U: invalid k. k is more then number of particles")}
sum<-0
for(i in 1:N){
if(i!=k){
sum<-sum+5*(r[var,k]-r[var,i])*(rki(r,k,i)^(-7))
}
}
sum<-2*r[var,k]-sum
sum
}
rki<-function(r,k,i){##calculates the distance between particle i and particle k;
##x, y, z (vectors) specify coordinates of all particles
rki<-NULL
if(k==i){print("rki error! k=i!")}
else{
rki<-((r[1,k]-r[1,i])^2+(r[2,k]-r[2,i])^2+(r[3,k]-r[3,i])^2)^0.5
}
names(rki)<-"Distance"
rki
}
U<-function(r){##returns a value of the potential energy of the system
N<-ncol(r)
U<-0
for(i in 1:N){
sum<-0
if(i<N){
for(k in (i+1):N){
sum<-sum+rki(r,k,i)^(-5)
}
}
U<-U+sum+r[1,i]^2+r[2,i]^2+r[3,i]^2
}
names(U)<-"Potential energy"
U
}
init<-function(N){##initializes matrix 3 times N with correct rownames and random values
r<-rbind(rnorm(N),rnorm(N),rnorm(N))
rownames(r)<-(c("x","y","z"))
r
}
delta<-function(r,alfa=1){##calculate vector of difference (one gradient descent iteration)
r2<-r
N<-ncol(r)
for(k in 1:N){
for(var in 1:3){
r2[var,k]<-r[var,k]-alfa*grad.U(r,var,k)
}
}
r2
}
reinit<-function(N){##loads r from file; returns it
file<-paste(c("data_init/",N,".csv"),collapse="")
r<-as.matrix(read.csv(file))
r
}
myplot<-function(r){
plot3d(r2[1,],r2[2,],r2[3,])
}##extends possibility of plot3d to plot a matrix 3xN
descent<-function(N=1:100,print=FALSE){##calcs descent over vector of N's and write each to a file
for(i in N){
r<-gradient.descent(i,alfa=1,K=100000, print=print)
file<-paste(c("data_init/",i,".csv"),collapse="")
write.csv(r,file=file,row.names=FALSE)
print(paste(c("printed file",file)),collapse="")
}
string<-paste(c("files for N=",paste(N,collapse=", ")," printed succesfully"), collapse="")
print(string)
}
rad<-function(r,k){##calculates the distance from particle k to the beginning of the coordinates
N<-ncol(r)
rad<-rep(0,times=N)
for(k in 1:N){
rad[k]<-r[1,k]^2+r[2,k]^2+r[3,k]
}
rad
}
rad<-function(r){##calculates the distance from particle k to the beginning of the coordinates
N<-ncol(r)
rad<-rep(0,times=N)
for(k in 1:N){
rad[k]<-r[1,k]^2+r[2,k]^2+r[3,k]
}
rad
}
r2<-rad(r)
r2
plot(r2)
rad<-function(r){##calculates the distance from particle k to the beginning of the coordinates
N<-ncol(r)
rad<-rep(0,times=N)
for(k in 1:N){
rad[k]<-r[1,k]^2+r[2,k]^2+r[3,k]^2
}
rad
}
r2<-rad(r)
r2
plot(r2)
myplot(r)
myplot<-function(r){
library(rgl)
plot3d(r2[1,],r2[2,],r2[3,])
}##extends possibility of plot3d to plot a matrix 3xN
myplot(r)
library(rgl)
plot3d(r[1,],r[2,],r[3,])
myplot<-function(r){
library(rgl)
plot3d(r[1,],r[2,],r[3,])
}##extends possibility of plot3d to plot a matrix 3xN
myplot(r)
?slice3d
?slice3D
library(plot3D)
?slice3D
colvar<-rep(1,times=21)
slice3D(r[1,],r[2,],r[3,],colvar)
colvar<-rbind(colvar,colvar,colvar)
colvar
slice3D(r[1,],r[2,],r[3,],colvar)
?array
var<-rad(r)
var
var<-rbind(var,var,var)
var
?slice3D
tr<-t(r)
tr
slice3D(tr[1,],tr[2,],tr[3,],colvar)
?slice3D
?array
var
array(var,dim=c(length(r[1,]),length(r[2,]),length(r[3,])))
arr<-array(var,dim=c(length(r[1,]),length(r[2,]),length(r[3,])))
arr
slice3D(r[1,],r[2,],r[3,],arr)
?array
array(rad(r),dim=3)
arr<-array(rad(r),dim=3)]
arr<-array(rad(r),dim=3)
slice3D(r[1,],r[2,],r[3,],arr)
colvar<-arr
slice3D(r[1,],r[2,],r[3,],colvar)
> require(akima) ; require(rgl)
> x=runif(1000)
> y=runif(1000)
> z=rnorm(1000)
> s=interp(x,y,z)
> dim(s$z)
[1] 40 40
> surface3d(s$x,s$y,s$z)
require(akima) ; require(rgl)
x=runif(1000)
y=runif(1000)
z=rnorm(1000)
s=interp(x,y,z)
dim(s$z)
install.packages(akima)
install.packages("akima")
librar(akima)
library(akima)
x=runif(1000)
y=runif(1000)
z=rnorm(1000)
s=interp(x,y,z)
dim(s$z)
surface3d(s$x,s$y,s$z)
surface3d(r[1,],r[2,],r[3,])
s<-interp((r[1,],r[2,],r[3,])
s<-interp(r[1,],r[2,],r[3,])
s
surface3d(s$x,s$y,s$z)
,yplot(r)
myplot(r)
myplot(r)
?plot3d
plot(rad(r))
rad<-1.5
rad
?plot3d
descent(22)
